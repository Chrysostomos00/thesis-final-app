{"ast":null,"code":"var _jsxFileName = \"/Users/tommys/Desktop/ai14/frontend/src/contexts/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport { fetchUserInfo } from '../services/api';\nimport { jwtDecode } from 'jwt-decode';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(null);\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [token, setToken] = useState(localStorage.getItem('token'));\n  const [user, setUser] = useState(null); // Stores { id, email, role, created_at }\n  const [isLoading, setIsLoading] = useState(true);\n  const verifyTokenAndFetchUser = useCallback(async currentToken => {\n    try {\n      const decodedToken = jwtDecode(currentToken);\n      const currentTime = Date.now() / 1000;\n      if (decodedToken.exp < currentTime) {\n        console.log(\"Token expired.\");\n        return null; // Indicate token is invalid\n      }\n      // Token seems valid structurally and time-wise, fetch user info to fully validate\n      const response = await fetchUserInfo(); // Uses interceptor with currentToken\n      return response.data; // Return user data { id, email, role, ... }\n    } catch (error) {\n      console.error(\"Token verification or user fetch failed:\", error);\n      // Check if the error is specifically a 401 from fetchUserInfo\n      if (error.response && error.response.status === 401) {\n        console.log(\"Token invalid according to server (401).\");\n      }\n      return null; // Indicate token/user is invalid\n    }\n  }, []); // No dependencies, fetchUserInfo uses token from storage via interceptor\n\n  useEffect(() => {\n    const initializeAuth = async () => {\n      setIsLoading(true);\n      const storedToken = localStorage.getItem('token');\n      let validUser = null;\n      if (storedToken) {\n        validUser = await verifyTokenAndFetchUser(storedToken);\n      }\n      if (validUser) {\n        setToken(storedToken);\n        setUser(validUser);\n        console.log(\"User authenticated:\", validUser.email, \"Role:\", validUser.role);\n      } else {\n        localStorage.removeItem('token'); // Clean up invalid token\n        setToken(null);\n        setUser(null);\n      }\n      setIsLoading(false);\n    };\n    initializeAuth();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Run only on mount\n\n  const login = useCallback(async newToken => {\n    localStorage.setItem('token', newToken);\n    setToken(newToken);\n    setIsLoading(true); // Indicate loading user info\n    const loggedInUser = await verifyTokenAndFetchUser(newToken);\n    if (loggedInUser) {\n      setUser(loggedInUser);\n    } else {\n      // Login succeeded but fetching user info failed immediately? Unlikely but possible.\n      localStorage.removeItem('token');\n      setToken(null);\n      setUser(null);\n    }\n    setIsLoading(false);\n  }, [verifyTokenAndFetchUser]);\n  const logout = useCallback(() => {\n    localStorage.removeItem('token');\n    setToken(null);\n    setUser(null);\n    // Navigation should be handled by routing logic in App.js\n    console.log(\"User logged out.\");\n  }, []);\n  const value = {\n    token,\n    user,\n    // Contains user info including role\n    isLoading,\n    login,\n    logout,\n    isAuthenticated: !!token && !!user // Check user object as well\n  };\n\n  // Render children only after initial loading is complete\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 94,\n    columnNumber: 9\n  }, this);\n};\n\n// Custom hook remains the same\n_s(AuthProvider, \"kp+VB2Ik4IJ4+Ugk6OExuzrjxOk=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","fetchUserInfo","jwtDecode","jsxDEV","_jsxDEV","AuthContext","AuthProvider","children","_s","token","setToken","localStorage","getItem","user","setUser","isLoading","setIsLoading","verifyTokenAndFetchUser","currentToken","decodedToken","currentTime","Date","now","exp","console","log","response","data","error","status","initializeAuth","storedToken","validUser","email","role","removeItem","login","newToken","setItem","loggedInUser","logout","value","isAuthenticated","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","undefined","Error","$RefreshReg$"],"sources":["/Users/tommys/Desktop/ai14/frontend/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport { fetchUserInfo } from '../services/api';\nimport { jwtDecode } from 'jwt-decode';\n\nconst AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n    const [token, setToken] = useState(localStorage.getItem('token'));\n    const [user, setUser] = useState(null); // Stores { id, email, role, created_at }\n    const [isLoading, setIsLoading] = useState(true);\n\n    const verifyTokenAndFetchUser = useCallback(async (currentToken) => {\n        try {\n            const decodedToken = jwtDecode(currentToken);\n            const currentTime = Date.now() / 1000;\n            if (decodedToken.exp < currentTime) {\n                console.log(\"Token expired.\");\n                return null; // Indicate token is invalid\n            }\n            // Token seems valid structurally and time-wise, fetch user info to fully validate\n            const response = await fetchUserInfo(); // Uses interceptor with currentToken\n            return response.data; // Return user data { id, email, role, ... }\n        } catch (error) {\n            console.error(\"Token verification or user fetch failed:\", error);\n             // Check if the error is specifically a 401 from fetchUserInfo\n             if (error.response && error.response.status === 401) {\n                console.log(\"Token invalid according to server (401).\");\n             }\n            return null; // Indicate token/user is invalid\n        }\n    }, []); // No dependencies, fetchUserInfo uses token from storage via interceptor\n\n    useEffect(() => {\n        const initializeAuth = async () => {\n            setIsLoading(true);\n            const storedToken = localStorage.getItem('token');\n            let validUser = null;\n\n            if (storedToken) {\n                validUser = await verifyTokenAndFetchUser(storedToken);\n            }\n\n            if (validUser) {\n                setToken(storedToken);\n                setUser(validUser);\n                console.log(\"User authenticated:\", validUser.email, \"Role:\", validUser.role);\n            } else {\n                localStorage.removeItem('token'); // Clean up invalid token\n                setToken(null);\n                setUser(null);\n            }\n            setIsLoading(false);\n        };\n\n        initializeAuth();\n         // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []); // Run only on mount\n\n    const login = useCallback(async (newToken) => {\n        localStorage.setItem('token', newToken);\n        setToken(newToken);\n        setIsLoading(true); // Indicate loading user info\n        const loggedInUser = await verifyTokenAndFetchUser(newToken);\n        if (loggedInUser) {\n            setUser(loggedInUser);\n        } else {\n            // Login succeeded but fetching user info failed immediately? Unlikely but possible.\n            localStorage.removeItem('token');\n            setToken(null);\n            setUser(null);\n        }\n        setIsLoading(false);\n    }, [verifyTokenAndFetchUser]);\n\n    const logout = useCallback(() => {\n        localStorage.removeItem('token');\n        setToken(null);\n        setUser(null);\n        // Navigation should be handled by routing logic in App.js\n        console.log(\"User logged out.\");\n    }, []);\n\n    const value = {\n        token,\n        user, // Contains user info including role\n        isLoading,\n        login,\n        logout,\n        isAuthenticated: !!token && !!user, // Check user object as well\n    };\n\n    // Render children only after initial loading is complete\n    return (\n        <AuthContext.Provider value={value}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\n// Custom hook remains the same\nexport const useAuth = () => {\n    const context = useContext(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}