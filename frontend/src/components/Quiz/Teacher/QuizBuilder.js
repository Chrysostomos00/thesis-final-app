import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { DndContext, closestCenter, PointerSensor, KeyboardSensor, useSensor, useSensors } from '@dnd-kit/core';
import { SortableContext, arrayMove, verticalListSortingStrategy, sortableKeyboardCoordinates } from '@dnd-kit/sortable';
import { v4 as uuidv4 } from 'uuid';
import { FaSave, FaPlus, FaArrowLeft, FaTrash, FaEye, FaEyeSlash, FaQuestionCircle, FaCheck,  FaSpinner } from 'react-icons/fa';

import QuizGeneratorAI from './QuizGeneratorAI';
import QuestionEditor from './QuestionEditor'; // Θα δημιουργήσουμε αυτό το component
import { createTeacherQuiz, getTeacherQuizDetails, updateTeacherQuiz } from '../../../services/api';
import '../../../styles/QuizComponents.css'; // Κοινό CSS

function QuizBuilder() {
    const { quizId } = useParams(); // Get quizId from URL if editing
    const navigate = useNavigate();
    const [quizTitle, setQuizTitle] = useState('');
    const [quizDescription, setQuizDescription] = useState('');
    const [questions, setQuestions] = useState([]); // Array of question objects
    const [isPublished, setIsPublished] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [activeId, setActiveId] = useState(null); // For DnD active item

    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
    );

    // --- Utility Functions ---
    const clearMessages = useCallback(() => { setError(''); setSuccess(''); }, []);
    const showSuccess = useCallback((msg) => { setSuccess(msg); setError(''); setTimeout(clearMessages, 3000); }, [clearMessages]);
    const showError = useCallback((msg) => { setError(msg); setSuccess(''); }, []);

    // --- Fetch existing quiz data if editing ---
    useEffect(() => {
        if (quizId) {
            setIsLoading(true);
            showSuccess(''); // Clear previous messages
            showError('');
            console.log(`Fetching quiz details for ID: ${quizId}`);
            getTeacherQuizDetails(quizId)
                .then(response => {
                    const quizData = response.data;
                    console.log("Fetched quiz data:", quizData);
                    setQuizTitle(quizData.title || '');
                    setQuizDescription(quizData.description || '');
                    setIsPublished(quizData.is_published || false);
                    // Ensure questions have unique temporary IDs for DnD and editing state
                    setQuestions(quizData.questions.map(q => ({ ...q, tempId: uuidv4(), isEditing: false })) || []);
                })
                .catch(err => {
                    console.error("Error fetching quiz details:", err);
                    showError(err.response?.data?.error || "Failed to load quiz details.");
                    navigate('/teacher/dashboard/quizzes'); // Redirect if loading fails
                })
                .finally(() => setIsLoading(false));
        } else {
             // Reset state for new quiz
             setQuizTitle('');
             setQuizDescription('');
             setQuestions([]);
             setIsPublished(false);
             setIsLoading(false);
        }
        // Include navigate and showError in dependencies if needed by eslint rules
    }, [quizId, navigate, showError, showSuccess]);

    // --- Handle Questions Generated by AI ---
    const handleQuestionsGenerated = (generatedQuestions) => {
        if (!Array.isArray(generatedQuestions)) {
            showError("AI generation did not return a valid list of questions.");
            return;
        }
         if (generatedQuestions.length === 0 && !error) { // Check error state to avoid overwriting AI error
            showError("AI did not generate any questions. Try adjusting the context or parameters.");
            return;
        }
        console.log("Adding AI generated questions:", generatedQuestions);
        // Add temporary IDs and default state
        const newQuestions = generatedQuestions.map((q, index) => ({
            ...q,
            id: null, // AI generated questions don't have DB IDs yet
            tempId: uuidv4(), // Unique ID for React key and DnD
            order_index: questions.length + index, // Assign order based on current length
            isEditing: false, // Default to not editing
            // Standardize choices format if needed
            choices: Array.isArray(q.choices) ? q.choices.map((choiceText, choiceIndex) => ({
                id: null, // No DB ID yet
                tempId: uuidv4(),
                choice_text: typeof choiceText === 'string' ? choiceText : (choiceText?.choice_text || ''),
                is_correct: (typeof choiceText === 'string' && q.correct_answer === choiceText) || (choiceText?.is_correct === true) || (q.correct_answer === choiceText?.choice_text)
            })) : [],
        })).filter(q => q.question_text && q.choices.length > 0); // Basic filter for valid questions

        // Ensure exactly one correct answer is marked per generated MCQ
        newQuestions.forEach(q => {
            if (q.question_type === 'mcq') {
                const correctChoices = q.choices.filter(c => c.is_correct);
                if (correctChoices.length !== 1) {
                     console.warn(`AI generated question "${q.question_text}" has ${correctChoices.length} correct answers. Adjusting...`);
                     // Simple fix: mark only the first choice listed as 'correct_answer' if possible, otherwise mark the first choice
                     let corrected = false;
                     q.choices.forEach((c, index) => {
                          if (!corrected && c.choice_text === q.correct_answer) {
                               c.is_correct = true;
                               corrected = true;
                          } else {
                               c.is_correct = false;
                          }
                     });
                     // If still no correct answer found (e.g., correct_answer text didn't match), mark the first one
                     if (!corrected && q.choices.length > 0) {
                          q.choices[0].is_correct = true;
                          console.warn(`Marked first choice as correct for question "${q.question_text}" as fallback.`);
                     }
                }
            }
        });


        setQuestions(prev => [...prev, ...newQuestions]);
        showSuccess(`${newQuestions.length} questions generated by AI. Please review and edit.`);
    };

    // --- Handle Manual Question Add ---
    const addEmptyQuestion = () => {
        clearMessages();
        const newQuestion = {
            id: null, // No DB ID yet
            tempId: uuidv4(),
            question_text: '',
            question_type: 'mcq', // Default to multiple choice
            order_index: questions.length,
            choices: [{ tempId: uuidv4(), choice_text: '', is_correct: true }], // Start with one correct choice
            isEditing: true, // Start in editing mode
        };
        setQuestions(prev => [...prev, newQuestion]);
    };

    // --- Handle Question Updates from Editor ---
    const handleUpdateQuestion = (tempId, updatedQuestionData) => {
         // This is called by QuestionEditor when SAVE is clicked
         console.log("Updating question:", tempId, updatedQuestionData);
        setQuestions(prev => prev.map(q =>
            q.tempId === tempId
            ? { ...q, ...updatedQuestionData, isEditing: false } // Apply updates and exit edit mode
            : q
        ));
    };

    const handleDeleteQuestion = (tempId) => {
        clearMessages();
        setQuestions(prev => prev.filter(q => q.tempId !== tempId));
    };

    const toggleEditMode = (tempId) => {
         clearMessages();
         setQuestions(prev => prev.map(q =>
            q.tempId === tempId ? { ...q, isEditing: !q.isEditing } : { ...q, isEditing: false } // Only one editing at a time
        ));
    };

    // --- Handle Drag and Drop Reordering ---
    const handleDragStart = (event) => setActiveId(event.active.id);

    const handleDragEnd = (event) => {
        const { active, over } = event;
        setActiveId(null);

        if (over && active.id !== over.id) {
             const oldIndex = questions.findIndex(q => q.tempId === active.id);
             const newIndex = questions.findIndex(q => q.tempId === over.id);

            if (oldIndex !== -1 && newIndex !== -1) {
                setQuestions(prev => {
                     const reordered = arrayMove(prev, oldIndex, newIndex);
                     // Update order_index after reordering
                     return reordered.map((q, index) => ({ ...q, order_index: index }));
                 });
            }
        }
    };

    // --- Handle Save Quiz ---
    const handleSaveQuiz = async () => {
        clearMessages();
        if (!quizTitle.trim()) { showError("Quiz title is required."); return; }
        if (questions.length === 0) { showError("Quiz must have at least one question."); return; }

        // Basic validation before saving (e.g., ensure MCQs have a correct answer)
        for (const q of questions) {
            if (q.isEditing) {
                showError(`Please save or cancel changes for question: "${q.question_text.substring(0,30)}..."`);
                return;
            }
            if (q.question_type === 'mcq') {
                 if (!q.choices || q.choices.length < 2) {
                     showError(`Multiple choice question "${q.question_text.substring(0,30)}..." must have at least 2 choices.`);
                     return;
                 }
                const correctCount = q.choices.filter(c => c.is_correct).length;
                if (correctCount !== 1) {
                     showError(`Multiple choice question "${q.question_text.substring(0,30)}..." must have exactly one correct answer marked.`);
                     return;
                }
                if (q.choices.some(c => !c.choice_text.trim())) {
                     showError(`All choices for question "${q.question_text.substring(0,30)}..." must have text.`);
                     return;
                }
            }
             if (!q.question_text.trim()) {
                showError(`Question text cannot be empty (Question #${q.order_index + 1}).`);
                return;
            }
        }


        setIsSaving(true);
        showError('');
        showSuccess('');

        // Prepare data for API (map frontend state to backend expected format)
        const quizDataPayload = {
            title: quizTitle.trim(),
            description: quizDescription.trim(),
            is_published: isPublished,
            questions: questions.map(q => ({
                id: q.id, // Send existing ID if updating, null if new
                question_text: q.question_text,
                question_type: q.question_type,
                order_index: q.order_index,
                // Prepare choices, removing temporary IDs
                choices: q.question_type === 'mcq' ? q.choices.map(c => ({
                     id: c.id, // Send existing ID if updating, null if new
                     choice_text: c.choice_text,
                     is_correct: c.is_correct
                 })) : [] // Send empty array for non-mcq for now
            }))
        };

        console.log("Saving/Updating Quiz Payload:", quizDataPayload);

        try {
            let response;
            if (quizId) {
                // Update existing quiz
                response = await updateTeacherQuiz(quizId, quizDataPayload);
                showSuccess("Quiz updated successfully!");
                // Optionally update local state if needed, though often navigating away
                // If staying on page, might need to refresh question IDs/tempIds
            } else {
                // Create new quiz
                response = await createTeacherQuiz(quizDataPayload);
                showSuccess("Quiz created successfully!");
                // Navigate to the edit page of the newly created quiz (or quiz list)
                navigate(`/teacher/dashboard/quizzes/edit/${response.data.id}`);
            }
        } catch (err) {
            console.error("Error saving quiz:", err);
            showError(err.response?.data?.error || "Failed to save quiz.");
        } finally {
            setIsSaving(false);
        }
    };


    if (isLoading) {
        return <div className='loading-fullscreen'> <FaSpinner className='spin' /> Loading Quiz...</div>;
    }

    return (
        <div className="quiz-builder-page">
             <div className="page-header">
                <button onClick={() => navigate('/teacher/dashboard/quizzes')} className='subtle-button back-button'>
                    <FaArrowLeft /> Back to Quizzes
                </button>
                <h2>{quizId ? 'Edit Quiz' : 'Create New Quiz'}</h2>
                <button onClick={handleSaveQuiz} disabled={isSaving || questions.some(q => q.isEditing)}>
                    <FaSave /> {isSaving ? 'Saving...' : (quizId ? 'Update Quiz' : 'Save Quiz')}
                </button>
             </div>

            {error && <div className="message error-message global-message">{error} <button onClick={clearMessages}>X</button></div>}
            {success && <div className="message success-message global-message">{success} <button onClick={clearMessages}>X</button></div>}

             <div className="quiz-builder-container">
                 {/* Quiz Metadata */}
                 <div className="quiz-metadata widget">
                     <h3>Quiz Details</h3>
                     <div className="form-group">
                         <label htmlFor="quiz-title">Quiz Title <span className="required">*</span></label>
                         <input
                            type="text"
                            id="quiz-title"
                            value={quizTitle}
                            onChange={(e) => setQuizTitle(e.target.value)}
                            placeholder="Enter a title for the quiz"
                            required
                         />
                     </div>
                     <div className="form-group">
                         <label htmlFor="quiz-description">Description (Optional)</label>
                         <textarea
                             id="quiz-description"
                             rows="3"
                             value={quizDescription}
                             onChange={(e) => setQuizDescription(e.target.value)}
                             placeholder="Provide instructions or context for the student"
                          />
                     </div>
                     <div className="form-group publish-toggle">
                         <label htmlFor="quiz-publish">
                            <input
                                type="checkbox"
                                id="quiz-publish"
                                checked={isPublished}
                                onChange={(e) => setIsPublished(e.target.checked)}
                             />
                             {isPublished ? <FaEye/> : <FaEyeSlash/>}
                              {isPublished ? ' Published (Visible to Students)' : ' Draft (Hidden from Students)'}
                         </label>
                          <span className="hint-text">(You can change this later)</span>
                     </div>
                 </div>

                 {/* AI Generator (only shows if creating new or maybe as option?) */}
                 {!quizId && ( // Only show generator when creating a new quiz for simplicity
                     <QuizGeneratorAI
                         onQuestionsGenerated={handleQuestionsGenerated}
                         showLoading={setIsSaving} // Reuse saving state as general loading indicator
                         hideLoading={() => setIsSaving(false)}
                         showError={showError}
                     />
                 )}

                 {/* Questions Area */}
                 <div className="quiz-questions-area widget">
                    <h3>Questions ({questions.length})</h3>
                    <DndContext
                        sensors={sensors}
                        collisionDetection={closestCenter}
                        onDragStart={handleDragStart}
                        onDragEnd={handleDragEnd}
                    >
                        <SortableContext items={questions.map(q => q.tempId)} strategy={verticalListSortingStrategy}>
                            {questions.map((q, index) => (
                                <QuestionEditor
                                    key={q.tempId}
                                    questionData={q} // Pass the full question object
                                    index={index}
                                    onUpdate={(updatedData) => handleUpdateQuestion(q.tempId, updatedData)}
                                    onDelete={() => handleDeleteQuestion(q.tempId)}
                                    isEditing={q.isEditing} // Pass edit state
                                    onToggleEdit={() => toggleEditMode(q.tempId)} // Pass handler to toggle edit
                                    activeId={activeId} // For Sortable styling if needed
                                />
                            ))}
                        </SortableContext>
                     </DndContext>

                    <button onClick={addEmptyQuestion} className="add-question-button">
                        <FaPlus /> Add Question Manually
                    </button>
                 </div>
             </div>
        </div>
    );
}

export default QuizBuilder;